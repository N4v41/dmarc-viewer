{% extends 'myDmarcApp/base.html' %}

{% block title %}MyDmarc - Deep Analysis{% endblock %}

{% block content %}
{% load staticfiles %}
{% load my_filters %}
<div class="col-sm-3 col-md-2 sidebar">
    <ul class="nav nav-sidebar">
    {% for view in sidebar_views %}
        <li {% if view.id == the_view.id %}class="active"{% endif %}><a href="/deep-analysis/{{view.id}}/">{{view.title}}</a></li>
    {% endfor %}
    </ul>
</div>
<div class="col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main">
    <h1>Deep Analysis</h1>
    <h2>{{the_view.title}}</h2>
    <p>{{the_view.description}}</p>

    {% comment %}
        
    <div class="view-filter-details">
        <p>View Filter Details</p>
        {% with the_view.viewfilterfield_set.all|first as timefilter %}
            {{timefilter}}
        {% endwith %}
        {% for fs in the_view.filterset_set.all %}
            {{fs.label}}:
            {% for f in fs.filtersetfilterfield_set.all%}
                {{f.report_field}}: {{f.value}}
            {% endfor %}

        {% endfor %}
    </div>
    {% endcomment %}

    {% if the_view.type_line %}
    <div class="view-type-linechart"></div>
    <script type="text/javascript">
        // Create margins, heights, widths for both plots
        var margin = {top: 40, right: 10, bottom: 100, left: 40},
            marginMini = {top: 430, right: 10, bottom: 20, left: 40},
            width = 960 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom,
            heightMini = 500 - marginMini.top - marginMini.bottom;

        // Create date format praser
        var parseDate = d3.time.format("%Y%m%d").parse;

        // Ranges for both plots
        var x = d3.time.scale().range([0, width]),
            y = d3.scale.linear().range([height, 0]),
            xMini = d3.time.scale().range([0, width]),
            yMini = d3.scale.linear().range([heightMini, 0]);

        //Axis for both plots
        var xAxis = d3.svg.axis().scale(x).orient("bottom"),
            yAxis = d3.svg.axis().scale(y).orient("left"),
            xAxisMini = d3.svg.axis().scale(xMini).orient("bottom");

        var xGridLines = d3.svg.axis().scale(x).orient("bottom").tickSize(-height, 0, 0).tickFormat(""),
            yGridLines = d3.svg.axis().scale(y).orient("left").tickSize(-width, 0, 0).tickFormat("");

        //Moving a brush in mini chart changes chart domain
        var brush = d3.svg.brush()
            .x(xMini)
            .on("brush", function() { 
              x.domain(brush.empty() ? xMini.domain() : brush.extent());
              focus.selectAll(".line").attr("d", line);
              focus.select(".x.axis").call(xAxis);
              focus.select(".x.grid").call(xGridLines);
            });

        //Append svg to document
        var svg = d3.select(".view-type-linechart").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        //Define a viewport, so that the line does not move over axis
        svg.append("defs").append("clipPath")
            .attr("id", "clip")
          .append("rect")
            .attr("width", width)
            .attr("height", height);

        // Append main chart to svg and place it
        var focus = svg.append("g")
            .attr("class", "focus")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Append overview chart to svg and place it 
        var context = svg.append("g")
            .attr("class", "context")
            .attr("transform", "translate(" + marginMini.left + "," + marginMini.top + ")");

        // Create main chart line generator
        var line = d3.svg.line()
            .x(function(d) { return x(d.date); })
            .y(function(d) { return y(d.cnt); });

        // Create overview chart line generator
        var lineMini = d3.svg.line()
            .x(function(d) { return xMini(d.date); })
            .y(function(d) { return yMini(d.cnt); });

        // Get the data
        // XXX LP Maybe get this with ajax
        var lineData = {{ view_type_line_data | to_json }};
        var dataSets = lineData.data_sets;
        var begin    = parseDate(lineData.begin);
        var end      = parseDate(lineData.end);

        // Convert date strings to dates
        dataSets.forEach(function(dataSet){
          dataSet.data.forEach(function(obj){
            obj.date = parseDate(obj.date);
          })
        })

        //Create 0 data points for days of range that are not in the dataset
        //data MUST be orderd by date
        var days = d3.time.day.range(begin, end);
        dataSets.forEach(function(dataSet){
            data_len = dataSet.data.length;
            data_tmp = [];
            var j = 0;
            for (var i = 0; i < days.length; i++) {
                // + for number cast
                if ((data_len > j) && (+days[i] == +dataSet.data[j].date)){
                    cnt = dataSet.data[j].cnt; 
                    j += 1;
                } else {
                    cnt = 0;
                }
                data_tmp.push({date: days[i], cnt: cnt});
            }
            dataSet.data = data_tmp
        });

        // Get min and max date by traversing all datasets' data lists
        
        x.domain([begin, end]);

        // Get max value by traversing all datasets' data lists
        y.domain(
          [0, d3.max([].concat.apply([], 
            dataSets.map(function(dataSet){return dataSet.data.map(
              function(d){return d.cnt; })})))]);

        // Get the domains for x and y values for overview chart
        xMini.domain(x.domain());
        yMini.domain(y.domain());

        // Create the actual lines and append to svg
        dataSets.forEach(function(dataSet, idx) {
          // for main chart
          focus.append("path")
              .datum(dataSet.data)
              .attr("class", "line")
              .attr("d", line)
              .attr('stroke', dataSet.color);
          // and for mini chart
          context.append("path")
              .datum(dataSet.data)
              .attr("class", "line")
              .attr("d", lineMini)
              .attr('stroke', dataSet.color);
        });

        // Append X Axis for main chart
        focus.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis);

        // Append Y Axis for main chart
        focus.append("g")
            .attr("class", "y axis")
            .call(yAxis);

        // prepend gridlines, so they are under the lines 
        focus.insert("g", ":first-child")
            .attr("class", "x grid")
            .attr("transform", "translate(0," + height + ")")
            .call(xGridLines);
        focus.insert("g", ":first-child")
            .attr("class", "y grid")
            .call(yGridLines);

        svg.append("text")
            .attr("transform", "translate(" + (width / 2) + " ," + margin.top / 2 + ")")
            .attr("class", "x label")
            .style("text-anchor", "middle")
            .text("Time");

        svg.append("text")
            .attr("class", "y label")
            .attr("transform", "rotate(-90)")
            .attr("y", margin.left / 2)
            .attr("x", 0 - (height / 2))
            .style("text-anchor", "middle")
            .text("Message Count");

        // Append X Axis for mini chart
        context.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + heightMini + ")")
            .call(xAxisMini);

        // Append the moving window for the mini chart
        context.append("g")
            .attr("class", "x brush")
            .call(brush)
          .selectAll("rect")
            .attr("y", -6)
            .attr("height", heightMini + 7);

        // Create a legend
        var legendItemRectSize = 18,
            legendSpacing = 4;
            
        var legend = svg.append('g')
            .attr('transform', 
                'translate(' + (margin.left + 10) + ',' + (margin.top + 10) + ')')
            .attr('class', 'legend')

        var legendItem = legend.selectAll('.legend-item')
          .data(dataSets)
          .enter()
          .append('g')
          .attr('class', 'legend-item')
          .attr('transform', function(d, i) {
            var itemHeight = legendItemRectSize + legendSpacing;
            var horz = legendSpacing;
            var vert = legendSpacing + i * itemHeight;
            return 'translate(' + horz + ',' + vert + ')';
          });

        legendItem.append('rect')
          .attr('width', legendItemRectSize)
          .attr('height', legendItemRectSize)
          .style('fill', function(d){return d.color})
          .style('stroke', function(d){return d.color});

        legendItem.append('text')
          .attr('x', legendItemRectSize + legendSpacing)
          .attr('y', legendItemRectSize - legendSpacing)
          .text(function(dataSet) { return dataSet.label; });

        legendBBox = $('.legend')[0].getBBox();
        legend.insert('rect', ':first-child')
            .attr('class', 'legend-box')
            .attr('width', legendBBox.width + 2 * legendSpacing)
            .attr('height', legendBBox.height + 2 * legendSpacing)
            .style('fill', 'white')
            .style('stroke', 'black');

    </script>
    {% endif %}


    {% if the_view.type_table %}
        
    <div class="view-type-table">
        <table class="table table-striped table-bordered dt-responsive nowrap" cellspacing="0" width="100%">
            <thead>
                <tr>
                    <th>Reporter</th>
                    <th>Mail sender</th>
                    <th>IP</th>
                    <th>Country</th>
                    <th>Report Time</th>
                    <th>Message #</th>
                    <th>DKIM Domains</th>
                    <th>DKIM Results</th>
                    <th>aligned DKIM</th>
                    <th>SPF Domains</th>
                    <th>SPF Results</th>
                    <th>aligned SPF</th>
                    <th>Disposition</th>
                    <th>Label</th>
                </tr>
            </thead>

            {% for filter_set_data in view_type_table_data  %}
                {% for record in filter_set_data.records %}
                    <tr style="background-color:{{filter_set_data.filter_set.color}}">
                        <td>{{record.report.reporter.org_name}}</td>
                        <td>{{record.report.domain}}</td>
                        <td>{{record.source_ip}}</td>
                        <td>{{record.country_iso_code}}</td>
                        {% comment %}
                        XXX LP: Only display borth dates if it ranges over multiple days
                        <td>{{report.date_range_begin | date:"Y/n/j"}} {{report.date_range_end | date:"Y/n/j"}}</td>
                        {% endcomment %}
                        <td>{{record.report.date_range_begin | date:"Y/n/j"}} </td>

                        <td>{{record.count}}</td>
                        {% comment %}
                            XXX LP: Think of ordering in nested table cells!!!
                        {% endcomment %}
                        <td>
                            {% for dkim in record.authresultdkim_set.all%}
                                {{dkim.domain}}
                            {% endfor %}
                        </td>
                        <td>
                            {% for dkim in record.authresultdkim_set.all%}
                                {{dkim.get_result_display}}
                            {% endfor %}
                        </td>
                        <td>{{record.get_dkim_display}}</td>
                        <td>
                            {% for spf in record.authresultspf_set.all%}
                                {{spf.domain}}
                            {% endfor %}
                        </td>
                        <td>
                            {% for spf in record.authresultspf_set.all%}
                                {{spf.get_result_display}}
                            {% endfor %}
                        </td>
                        <td>{{record.get_spf_display}}</td>
                        <td>{{record.get_disposition_display}}</td>
                        <td>{{filter_set_data.filter_set.label}}</td>
                    </tr>
                {% endfor %}
            {% endfor %}
        </table>
    </div>
    <a class="btn btn-info" role="button" href="/edit-view/{{the_view.id}}/">Edit</a>

    <script type="text/javascript">
        /*
         * Initialize DataTable 
         */
        $(document).ready(function(){
            $('.view-type-table table').DataTable({
                paging: true,
            });
        });
    </script>
    {% endif %}

    {% if the_view.type_map %}

    <div class="view-type-map"></div>
    <script type="text/javascript">
        // XXX LP: Only temp, don't worry. :)
        var countryCodeMapping = {"AF": "AFG", "AL": "ALB", "DZ": "DZA", "AD": "AND", "AO": "AGO", "AG": "ATG", "AR": "ARG", "AM": "ARM", "AU": "AUS", "AT": "AUT", "AZ": "AZE", "BS": "BHS", "BH": "BHR", "BD": "BGD", "BB": "BRB", "BY": "BLR", "BE": "BEL", "BZ": "BLZ", "BJ": "BEN", "BT": "BTN", "BO": "BOL", "BA": "BIH", "BW": "BWA", "BR": "BRA", "BN": "BRN", "BG": "BGR", "BF": "BFA", "BI": "BDI", "KH": "KHM", "CM": "CMR", "CA": "CAN", "CV": "CPV", "CF": "CAF", "TD": "TCD", "CL": "CHL", "CO": "COL", "KM": "COM", "24": ",CD", "24": ",CG", "CR": "CRI", "CI": "CIV", "HR": "HRV", "CU": "CUB", "CY": "CYP", "CZ": "CZE", "DK": "DNK", "DJ": "DJI", "DM": "DMA", "DO": "DOM", "EC": "ECU", "EG": "EGY", "SV": "SLV", "GQ": "GNQ", "ER": "ERI", "EE": "EST", "ET": "ETH", "FJ": "FJI", "FI": "FIN", "FR": "FRA", "GA": "GAB", "22": ",GM", "GE": "GEO", "DE": "DEU", "GH": "GHA", "GR": "GRC", "GD": "GRD", "GT": "GTM", "GN": "GIN", "GW": "GNB", "GY": "GUY", "HT": "HTI", "HN": "HND", "HU": "HUN", "IS": "ISL", "IN": "IND", "ID": "IDN", "IR": "IRN", "IQ": "IRQ", "IE": "IRL", "IL": "ISR", "IT": "ITA", "JM": "JAM", "JP": "JPN", "JO": "JOR", "KZ": "KAZ", "KE": "KEN", "KI": "KIR", "KW": "KWT", "KG": "KGZ", "LA": "LAO", "LV": "LVA", "LB": "LBN", "LS": "LSO", "LR": "LBR", "LY": "LBY", "LI": "LIE", "LT": "LTU", "LU": "LUX", "MK": "MKD", "MG": "MDG", "MW": "MWI", "MY": "MYS", "MV": "MDV", "ML": "MLI", "MT": "MLT", "MH": "MHL", "MR": "MRT", "MU": "MUS", "MX": "MEX", "FM": "FSM", "MD": "MDA", "MC": "MCO", "MN": "MNG", "ME": "MNE", "MA": "MAR", "MZ": "MOZ", "MM": "MMR", "NA": "NAM", "NR": "NRU", "NP": "NPL", "NL": "NLD", "NZ": "NZL", "NI": "NIC", "NE": "NER", "NG": "NGA", "NO": "NOR", "OM": "OMN", "PK": "PAK", "PW": "PLW", "PA": "PAN", "PG": "PNG", "PY": "PRY", "PE": "PER", "PH": "PHL", "PL": "POL", "PT": "PRT", "QA": "QAT", "RO": "ROU", "RU": "RUS", "RW": "RWA", "KN": "KNA", "LC": "LCA", "VC": "VCT", "WS": "WSM", "SM": "SMR", "ST": "STP", "SA": "SAU", "SN": "SEN", "RS": "SRB", "SC": "SYC", "SL": "SLE", "SG": "SGP", "SK": "SVK", "SI": "SVN", "SB": "SLB", "SO": "SOM", "ES": "ESP", "LK": "LKA", "SD": "SDN", "SR": "SUR", "SZ": "SWZ", "SE": "SWE", "CH": "CHE", "SY": "SYR", "TJ": "TJK", "TZ": "TZA", "TH": "THA", "TL": "TLS", "TG": "TGO", "TO": "TON", "TT": "TTO", "TN": "TUN", "TR": "TUR", "TM": "TKM", "TV": "TUV", "UG": "UGA", "UA": "UKR", "AE": "ARE", "GB": "GBR", "US": "USA", "UY": "URY", "UZ": "UZB", "VU": "VUT", "VA": "VAT", "VE": "VEN", "VN": "VNM", "YE": "YEM", "ZM": "ZMB", "ZW": "ZWE", "GE": "GEO", "TW": "TWN", "AZ": "AZE", "CY": "CYP", "MD": "MDA", "SO": "SOM", "GE": "GEO", "AU": "AUS", "CX": "CXR", "CC": "CCK", "AU": "AUS", "HM": "HMD", "NF": "NFK", "NC": "NCL", "PF": "PYF", "YT": "MYT", "GP": "GLP", "GP": "GLP", "PM": "SPM", "WF": "WLF", "TF": "ATF", "PF": "PYF", "BV": "BVT", "CK": "COK", "NU": "NIU", "TK": "TKL", "GG": "GGY", "IM": "IMN", "JE": "JEY", "AI": "AIA", "BM": "BMU", "IO": "IOT", "VG": "VGB", "KY": "CYM", "FK": "FLK", "GI": "GIB", "MS": "MSR", "PN": "PCN", "SH": "SHN", "GS": "SGS", "TC": "TCA", "MP": "MNP", "PR": "PRI", "AS": "ASM", "UM": "UMI", "GU": "GUM", "UM": "UMI", "UM": "UMI", "UM": "UMI", "UM": "UMI", "UM": "UMI", "UM": "UMI", "UM": "UMI", "VI": "VIR", "UM": "UMI", "HK": "HKG", "MO": "MAC", "FO": "FRO", "GL": "GRL", "GF": "GUF", "GP": "GLP", "MQ": "MTQ", "RE": "REU", "AX": "ALA", "AW": "ABW", "AN": "ANT", "SJ": "SJM", "AC": "ASC", "TA": "TAA", "AQ": "ATA", "AQ": "ATA"};

        /*
         * Creates an array of `n` colors around the baseColor.
         * Incrementing the HSL lightness value from 0.2 to 0.8
         * 
         * -> cf. "Color Use Guidelines for Mapping and Visualization",
         *  Brewer (sequential scheme, one hue)
         */
        function createColorRange(baseColor, n) {
            var colorHsl = d3.hsl(baseColor),
                minL = 0.2,
                maxL = 0.8;
            var stepSize = (maxL - minL) / n;
            var colors = [];
            for (var i = 0; i < n; i++ ){
                colorHsl.l = maxL - (i*stepSize)
                colors.push(colorHsl.toString());
                }
            return colors;
        }

        var mapDataSets = {{ view_type_map_data | to_json }};
        var mapDataSet = mapDataSets[1];

            // Get max
            var max = d3.max(mapDataSet.data.map(function(obj) {
                return obj.cnt;
            }))

            // Define a color 
            var colors = createColorRange(mapDataSet.color, 5)
            var paletteScale = d3.scale.quantize()
                .domain([1, max])
                .range(colors);

            // Create Dataset
            // {"iso_code" : {"fillKey": <key>, "numberOfThings": <cnt>}, ..}
            var dataset = {}
            mapDataSet.data.forEach(function(obj){ //
                dataset[countryCodeMapping[obj.country_iso_code]] = { numberOfThings: obj.cnt, fillKey: paletteScale(obj.cnt) };
            }); 

            // Create fills and legendLabels
            var defaultFill = "white";
            var defaultBorder = "darkgrey";
            var mapFills        = {defaultFill: defaultFill};
            var legendLabels    = {};
            colors.forEach(function(color){
                mapFills[color]     = color;
                var extents = paletteScale.invertExtent(color);
                legendLabels[color] = Math.round(extents[0]) + " - " + Math.round(extents[1]);
            });

            // Init the map
            var map = new Datamap({
                element: $(".view-type-map").get(0),
                projection: 'mercator',
                data: dataset,
                responsive: true,
                legend: true,
                geographyConfig: {
                    borderColor: defaultBorder,
                    borderWidth: 0.5,
                    highlightFillColor: defaultFill,
                    highlightBorderColor: defaultBorder,
                    highlightBorderWidth: 1,
                    popupTemplate: function(geo, data) {
                                    text = geo.properties.name + ": " + 
                                            (data ? data.numberOfThings : "no") +
                                            " messages"
                                    $hoverInfo = $("<div>", {"class": "hoverinfo", "text": text})
                                    return $hoverInfo.prop('outerHTML');
                                }
                },
                fills: mapFills,

            })
            // Add Legend
            map.legend({legendTitle: mapDataSet.label, defaultFillName: "0", labels: legendLabels});

            //Adding some responsiveness
            d3.select(window).on('resize', function() {
                map.resize();
            });
        </script>
    {% endif %}

</div>
{% endblock %}